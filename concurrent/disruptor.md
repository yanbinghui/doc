## Disruptor是什么

Disruptor是一个无锁的并发框架，能够实现Queue的高并发操作。

Martin Fowler在自己网站上写了一篇LMAX架构的文章，在文章中他介绍了LMAX是一种新型零售金融交易平台，它能够以很低的延迟产生大量交易。这个系统是建立在JVM平台上，其核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。**业务逻辑处理器完全是运行在内存中**，使用事件源驱动方式。业务逻辑处理器的核心是Disruptor。

简单来说，Disruptor是一个内存的环状无锁消息队列。

## 为什么使用disruptor

### 并发编程的特点

 - 可见性
 - 有序性
 - 原子性
 
 其中volatile解决了可见性和有序性，锁解决了原子性。atomicLong也可以解决原子性。

### 锁的缺点

锁主要分为两种，悲观锁和乐观锁。悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

用锁的时候，还有一个潜在的问题，就是死锁。

### disruptor怎样解决这个问题

首先，Disruptor根本就不用锁。

取而代之的是，在需要确保操作是线程安全的（特别是，在多生产者的环境下，更新下一个可用的序列号）地方，我们使用CAS（Compare And Swap/Set）操作。这是一个CPU级别的指令，在我的意识中，它的工作方式有点像乐观锁——CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。

CAS操作比锁消耗资源少的多，因为它们不牵涉操作系统，它们直接在CPU上操作。但它们并非没有代价——在上面的试验中，单线程无锁耗时300ms，单线程有锁耗时10000ms，单线程使用CAS耗时5700ms。所以它比使用锁耗时少，但比不需要考虑竞争的单线程耗时多。

具体来说，Disruptor的技术是：

1. AtomicLong（Java提供的CAS操作）

2. 使用ringbuffer，固定长度的数组，减少了内存的开辟和释放。

3. 针对ringbuffer存在的可能false sharing，使用cache line padding，减少了伪共享和非预期的竞争。

#### 伪共享

缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。

#### 缓存行填充

使用缓存行填充解决了伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。

```
public long p1, p2, p3, p4, p5, p6, p7; // cache line padding
private volatile long cursor = INITIAL_CURSOR_VALUE;
public long p8, p9, p10, p11, p12, p13, p14; // cache line padding
```

#### 内存屏障

内存屏障是一个CPU指令。没错，又一次，我们在讨论CPU级别的东西，以便获得我们想要的性能（Martin著名的Mechanical Sympathy理论）。基本上，它是这样一条指令： a)确保一些特定操作执行的顺序； b)影响一些数据的可见性(可能是某些指令执行后的结果)。

编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。正如去拉斯维加斯旅途中各个站点的先后顺序在你心中都一清二楚。内存屏障另一个作用是强制更新一次不同CPU的缓存。

内存屏障作为另一个CPU级的指令，没有锁那样大的开销。内核并没有在多个线程间干涉和调度。但凡事都是有代价的。内存屏障的确是有开销的——编译器/cpu不能重排序指令，导致不可以尽可能地高效利用CPU，另外刷新缓存亦会有开销。所以不要以为用volatile代替锁操作就一点事都没。


## 怎样使用disruptor


### ring buffer

### 如何读取

在消费者和ringbuffer之间存在一个ConsumerBarrier，与乐观锁不同的是，当buffer为空，不是consumer一直问“数据来了没？” 而是consumer原地等待，直到ConsumerBarrier通知说有了新的消息。

### 如何写入

在生产者和ringbuffer之后存在一个ProducerBarrier。写入分为两个阶段，第一个阶段是申请下一个节点，第二阶段是提交新的数据。

#### 多个生产者的场景

当有多个生产者的时候，如果同时多个生产者申请到写入节点，但是前面的提交较慢。这时候 ProducerBarrier 的ClaimStrategy就一直自旋，直到前面的生产者提交再修改可用位点。

## 总结

- 本质上是个ringbuffer,RingBuffer 复用内存，减少分配新空间带来的时间和空间损耗。
- buffer(就是数组)做过优化防止JVM伪共享，lock free 是通过CAS自旋，注意不是wait free，多线程并发获取buffer中的序号，在这里需要CAS，把事件放入槽中。
- 工作线程调度是交给jdk 线程池，只要buffer中有事件，就不停提交给线程池所以就是一个牛逼的临界区，无锁解决多线程读写
- Busy Spin（疯狂死循环）是多核架构上最快的通信方法，比所有要经 kernel 走信号量之类都快。当然也会带来更多的功耗和损耗。

## 参考文档

1. [并发框架Disruptor译文](http://ifeve.com/disruptor/)

